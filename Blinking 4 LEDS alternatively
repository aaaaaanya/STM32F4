#include"stm32f4xx.h"
//Interrupt handler that handles the interrupt generated by timer 4
void TIM4_IRQHandler(void);
int flag=0;

int main()
{
   
  //Enable the GPIOD Clock
 RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD,ENABLE );
  
   
 //GPIOD Configuration
 GPIO_InitTypeDef GPIO_InitStruct;
 GPIO_InitStruct.GPIO_Mode = GPIO_Mode_OUT;
 GPIO_InitStruct.GPIO_Speed = GPIO_Fast_Speed;
 GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;
 GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_UP;
   
 GPIO_InitStruct.GPIO_Pin = GPIO_Pin_12;
   GPIO_Init(GPIOD,&GPIO_InitStruct);
   
   GPIO_InitStruct.GPIO_Pin = GPIO_Pin_13;
   GPIO_Init(GPIOD,&GPIO_InitStruct);
   
   GPIO_InitStruct.GPIO_Pin = GPIO_Pin_14;
   GPIO_Init(GPIOD,&GPIO_InitStruct);
   
   GPIO_InitStruct.GPIO_Pin = GPIO_Pin_15;
   GPIO_SetBits(GPIOD, GPIO_Pin_14);
   GPIO_Init(GPIOD,&GPIO_InitStruct);
   
  
 //Enabling timer 4 clock(apb1)
   RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);  
   
//Timer configuration 
TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct;
//Time=(Prescalar+1) * (Period +1)/Clock frequency
  TIM_TimeBaseInitStruct.TIM_Prescaler = 27999; //(For 28MHz clock frequency) Divides the input clock frequency before it is used to increment the timer counter
  TIM_TimeBaseInitStruct.TIM_Period = 999; //(For 1s)Maximum value that the timer counter can reach before it overflows and resets to 0
 TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV1; //Divides clock frequency by DIV 1 (or others 2,4,8)
  TIM_TimeBaseInitStruct.TIM_CounterMode = TIM_CounterMode_Up; //Counts up from 0 to maximum value and then resets to 0
  //TIM_TimeBaseInitStruct.TIM_RepetitionCounter = 0x0000;////Meaning timer generates an interrupt on every overflow

  TIM_TimeBaseInit(TIM4,&TIM_TimeBaseInitStruct);
  
  
  
 //NVIC function
  NVIC_InitTypeDef NVIC_InitStruct;

  NVIC_InitStruct.NVIC_IRQChannel=TIM4_IRQn;
  NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority=0;//Priority level which determines which Interrupt should be executed if 2 or more are pending at the same time
  NVIC_InitStruct.NVIC_IRQChannelSubPriority=0;//Determines the order in which interrupts with the same preemption priority are executed
  NVIC_InitStruct.NVIC_IRQChannelCmd= ENABLE;//enables Timer 4 interrupt
 NVIC_Init(&NVIC_InitStruct);
  
  
 TIM_ITConfig(TIM4, TIM_IT_Update,ENABLE); //enables interrupt generation for timer 4 update event
  TIM_Cmd(TIM4,ENABLE); //Enables timer 4 counter
  TIM4_IRQHandler();
  
  while(1);
 
 return 0;
}

void TIM4_IRQHandler(void)
{
  //This clears the interrupt flag. If the interrupt flag is not cleared the interrupt will be continuously triggered. Thus its necessary to clear the interrupt flag after the interrupt has been serviced
 TIM_ClearITPendingBit(TIM4, TIM_IT_Update);
if (flag==0)
{
GPIO_ToggleBits(GPIOD, GPIO_Pin_15); //12
GPIO_ToggleBits(GPIOD, GPIO_Pin_14); //15
flag=1;
}
else if(flag==1)
{
GPIO_ToggleBits(GPIOD, GPIO_Pin_12); //13
GPIO_ToggleBits(GPIOD, GPIO_Pin_15); //12
flag=2;
}
else if(flag==2)
{
GPIO_ToggleBits(GPIOD, GPIO_Pin_13); //14
GPIO_ToggleBits(GPIOD, GPIO_Pin_12); //13
flag=3;
}
else if(flag==3)
{
GPIO_ToggleBits(GPIOD, GPIO_Pin_14); //15
GPIO_ToggleBits(GPIOD, GPIO_Pin_13); //12
flag=0;
}
}
